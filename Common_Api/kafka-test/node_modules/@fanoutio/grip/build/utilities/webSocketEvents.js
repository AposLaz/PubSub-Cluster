"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createWebSocketControlMessage = exports.decodeWebSocketEvents = exports.encodeWebSocketEvents = void 0;
var buffer_1 = require("buffer");
var WebSocketEvent_1 = __importDefault(require("../data/websocket/WebSocketEvent"));
var string_1 = require("./string");
// Encode the specified array of WebSocketEvent instances. The returned string
// value should then be passed to a GRIP proxy in the body of an HTTP response
// when using the WebSocket-over-HTTP protocol.
function encodeWebSocketEvents(events) {
    var out = buffer_1.Buffer.alloc(0);
    var bufferNewLine = buffer_1.Buffer.from('\r\n');
    for (var _i = 0, events_1 = events; _i < events_1.length; _i++) {
        var e = events_1[_i];
        var content = e.getContent();
        if (content != null) {
            if (string_1.isString(content)) {
                content = buffer_1.Buffer.from(content);
            }
            else {
                if (!buffer_1.Buffer.isBuffer(content)) {
                    content = buffer_1.Buffer.from(content);
                }
            }
            out = buffer_1.Buffer.concat([
                out,
                buffer_1.Buffer.from(e.getType()),
                buffer_1.Buffer.from(' '),
                buffer_1.Buffer.from(content.length.toString(16)),
                bufferNewLine,
                content,
                bufferNewLine,
            ]);
        }
        else {
            out = buffer_1.Buffer.concat([out, buffer_1.Buffer.from(e.getType()), bufferNewLine]);
        }
    }
    return out;
}
exports.encodeWebSocketEvents = encodeWebSocketEvents;
// Decode the specified HTTP request body into an array of WebSocketEvent
// instances when using the WebSocket-over-HTTP protocol. A RuntimeError
// is raised if the format is invalid.
function decodeWebSocketEvents(body) {
    var out = [];
    var start = 0;
    var makeContentString = false;
    if (string_1.isString(body)) {
        body = buffer_1.Buffer.from(body);
        makeContentString = true;
    }
    while (start < body.length) {
        var at = body.indexOf('\r\n', start);
        if (at === -1) {
            throw new Error('bad format');
        }
        var typeline = body.slice(start, at);
        start = at + 2;
        at = typeline.indexOf(' ');
        var e = null;
        if (at !== -1) {
            var etype = typeline.slice(0, at);
            var clen = parseInt(typeline.slice(at + 1).toString(), 16);
            var content = body.slice(start, start + clen);
            start = start + clen + 2;
            if (makeContentString) {
                e = new WebSocketEvent_1.default(etype.toString(), content.toString());
            }
            else {
                e = new WebSocketEvent_1.default(etype.toString(), content);
            }
        }
        else {
            e = new WebSocketEvent_1.default(typeline.toString());
        }
        out.push(e);
    }
    return out;
}
exports.decodeWebSocketEvents = decodeWebSocketEvents;
// Generate a WebSocket control message with the specified type and optional
// arguments. WebSocket control messages are passed to GRIP proxies and
// example usage includes subscribing/unsubscribing a WebSocket connection
// to/from a channel.
function createWebSocketControlMessage(type, args) {
    if (args === void 0) { args = null; }
    var out = Object.assign({}, args, { type: type });
    return JSON.stringify(out);
}
exports.createWebSocketControlMessage = createWebSocketControlMessage;
//# sourceMappingURL=webSocketEvents.js.map