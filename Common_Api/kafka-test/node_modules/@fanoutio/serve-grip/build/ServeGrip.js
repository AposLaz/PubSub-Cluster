"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var callable_instance_1 = __importDefault(require("callable-instance"));
var debug_1 = __importDefault(require("./debug"));
var grip_1 = require("@fanoutio/grip");
var GripInstructNotAvailableException_1 = __importDefault(require("./GripInstructNotAvailableException"));
var GripInstructAlreadyStartedException_1 = __importDefault(require("./GripInstructAlreadyStartedException"));
var PrefixedPublisher_1 = __importDefault(require("./PrefixedPublisher"));
function flattenHeader(value) {
    if (Array.isArray(value)) {
        return value[0];
    }
    return value;
}
var ServeGrip = /** @class */ (function (_super) {
    __extends(ServeGrip, _super);
    function ServeGrip(config) {
        var _this = _super.call(this, 'exec') || this;
        _this.prefix = '';
        _this.isGripProxyRequired = false;
        _this.applyConfig(config);
        _this.koa = function (ctx, next) { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.run(ctx.req, ctx.res)];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, next()];
                    case 2:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        }); };
        return _this;
    }
    ServeGrip.prototype.applyConfig = function (config) {
        if (config === void 0) { config = {}; }
        var grip = config.grip, _a = config.gripProxyRequired, gripProxyRequired = _a === void 0 ? false : _a, _b = config.prefix, prefix = _b === void 0 ? '' : _b;
        if (this._publisher != null) {
            throw new Error('applyConfig called on ServeGrip that already has an instantiated publisher.');
        }
        this.gripProxies = grip;
        this.isGripProxyRequired = gripProxyRequired;
        this.prefix = prefix;
    };
    ServeGrip.prototype.getPublisher = function () {
        debug_1.default('ServeGrip#getPublisher - start');
        if (this._publisher == null) {
            var publisher = void 0;
            if (this.gripProxies == null) {
                debug_1.default('ServeGrip#getPublisher - ERROR - no grip proxies specified');
                throw new Error('No Grip configuration provided. Provide one to the constructor of ServeGrip, or call applyConfig() with a Grip configuration, before calling getPublisher().');
            }
            if (this.gripProxies instanceof grip_1.Publisher) {
                debug_1.default('ServeGrip#getPublisher - initializing with existing publisher');
                publisher = this.gripProxies;
            }
            else {
                debug_1.default('ServeGrip#getPublisher - initializing with grip settings', this.gripProxies);
                publisher = new grip_1.Publisher();
                publisher.applyConfig(this.gripProxies);
            }
            this._publisher = new PrefixedPublisher_1.default(publisher, this.prefix);
        }
        else {
            debug_1.default('returning publisher');
        }
        debug_1.default('ServeGrip#getPublisher - end');
        return this._publisher;
    };
    ServeGrip.prototype.exec = function (req, res, fn) {
        debug_1.default('ServeGrip#exec - serveGrip invoked as Middleware function');
        var err;
        this.run(req, res)
            .catch(function (ex) { return (err = ex); })
            .then(function (result) {
            if (err !== undefined) {
                fn(err);
            }
            else {
                if (result) {
                    fn();
                }
            }
        });
    };
    ServeGrip.prototype.run = function (req, res) {
        return __awaiter(this, void 0, void 0, function () {
            var gripSigHeader_1, isProxied_1, isSigned, needsSigned, publisher, clients, wsContext_1, ex_1, gripInstruct_1, resRemoveHeader_1, resWriteHead_1, resEnd_1, resWriteHead_2, ex_2;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        debug_1.default('ServeGrip#run - start');
                        if (req.grip != null) {
                            // This would indicate that we are already running for this request.
                            // We don't install ourselves multiple times.
                            debug_1.default('Already ran for this request, returning true');
                            return [2 /*return*/, true];
                        }
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 6, , 7]);
                        // Config check
                        if (this.gripProxies == null) {
                            debug_1.default('ERROR - No Grip configuration provided. Send error, returning false');
                            res.statusCode = 500;
                            res.end('No Grip configuration provided.\n');
                            return [2 /*return*/, false];
                        }
                        debug_1.default("gripProxies", this.gripProxies);
                        // ## Set up req.grip
                        debug_1.default('Set up req.grip - start');
                        gripSigHeader_1 = flattenHeader(req.headers['grip-sig']);
                        isProxied_1 = false;
                        isSigned = false;
                        needsSigned = false;
                        if (gripSigHeader_1 !== undefined) {
                            debug_1.default('grip-sig header exists');
                            publisher = this.getPublisher();
                            clients = publisher.clients;
                            if (clients.length > 0) {
                                if (clients.every(function (client) { return client.auth instanceof grip_1.Auth.Jwt && client.auth.key != null; })) {
                                    needsSigned = true;
                                    // If all proxies have keys, then only consider the request
                                    // signed if at least one of them has signed it
                                    if (clients.some(function (client) {
                                        return grip_1.validateSig(gripSigHeader_1, client.auth.key);
                                    })) {
                                        isProxied_1 = true;
                                        isSigned = true;
                                    }
                                }
                                else {
                                    isProxied_1 = true;
                                }
                            }
                        }
                        if (isProxied_1) {
                            debug_1.default('Request is proxied');
                        }
                        else {
                            debug_1.default('Request is not proxied');
                        }
                        if (isSigned) {
                            debug_1.default('Request is signed');
                        }
                        else {
                            debug_1.default('Request is not signed');
                        }
                        if (!isProxied_1 && this.isGripProxyRequired) {
                            // If we require a GRIP proxy but we detect there is
                            // not one, we needs to fail now
                            debug_1.default('ERROR - isGripProxyRequired is true, but is not proxied. Send error, returning false.');
                            res.statusCode = 501;
                            res.end('Not Implemented.\n');
                            return [2 /*return*/, false];
                        }
                        wsContext_1 = null;
                        if (!grip_1.isWsOverHttp(req)) return [3 /*break*/, 5];
                        _a.label = 2;
                    case 2:
                        _a.trys.push([2, 4, , 5]);
                        return [4 /*yield*/, grip_1.getWebSocketContextFromReq(req, this.prefix)];
                    case 3:
                        wsContext_1 = _a.sent();
                        return [3 /*break*/, 5];
                    case 4:
                        ex_1 = _a.sent();
                        if (ex_1 instanceof grip_1.ConnectionIdMissingException) {
                            debug_1.default("ERROR - connection-id header needed. Send Error, returning false");
                            res.statusCode = 400;
                            res.end('WebSocket event missing connection-id header.\n');
                            return [2 /*return*/, false];
                        }
                        if (ex_1 instanceof grip_1.WebSocketDecodeEventException) {
                            debug_1.default("ERROR - error parsing websocket events. Send Error, returning false");
                            res.statusCode = 400;
                            res.end('Error parsing WebSocket events.\n');
                            return [2 /*return*/, false];
                        }
                        debug_1.default("ERROR - unknown exception getting web socket context from request");
                        debug_1.default(ex_1);
                        res.statusCode = 400;
                        res.end('Error getting web socket Context.\n');
                        return [2 /*return*/, false];
                    case 5:
                        Object.assign(req, {
                            grip: {
                                isProxied: isProxied_1,
                                isSigned: isSigned,
                                needsSigned: needsSigned,
                                wsContext: wsContext_1,
                            },
                        });
                        debug_1.default('Set up req.grip - end');
                        // ## Set up res.grip
                        debug_1.default('Set up res.grip - start');
                        gripInstruct_1 = null;
                        Object.assign(res, {
                            grip: {
                                startInstruct: function () {
                                    try {
                                        debug_1.default('startInstruct - start');
                                        // In WebSocket-over-HTTP or if request is not proxied,
                                        // startInstruct is not available.
                                        if (wsContext_1 == null && isProxied_1) {
                                            if (gripInstruct_1 != null) {
                                                debug_1.default('ERROR - GripInstruct is already started');
                                                throw new GripInstructAlreadyStartedException_1.default();
                                            }
                                            debug_1.default('Creating GripInstruct');
                                            gripInstruct_1 = new grip_1.GripInstruct();
                                            return gripInstruct_1;
                                        }
                                        else {
                                            debug_1.default('ERROR - GripInstruct is not available');
                                            throw new GripInstructNotAvailableException_1.default();
                                        }
                                    }
                                    finally {
                                        debug_1.default('startInstruct - end');
                                    }
                                },
                            },
                        });
                        debug_1.default('Set up res.grip - end');
                        // ## Monkey-patch res methods
                        if (wsContext_1 != null) {
                            debug_1.default('Monkey-patch res methods for WS-over-HTTP - start');
                            debug_1.default('res.removeHeader');
                            resRemoveHeader_1 = res.removeHeader;
                            // @ts-ignore
                            res.removeHeader = function (name) {
                                debug_1.default('res.removeHeader - start');
                                // If we have a WsContext, then we don't want to allow removing
                                // the following headers.
                                var skip = false;
                                if (name != null) {
                                    var nameLower = name.toLowerCase();
                                    if (nameLower === 'content-type' ||
                                        nameLower === 'content-length' ||
                                        nameLower === 'transfer-encoding') {
                                        // turn into a no-op
                                        skip = true;
                                    }
                                }
                                if (!skip) {
                                    debug_1.default('not skipping removeHeader', name);
                                    resRemoveHeader_1.call(res, name);
                                }
                                else {
                                    debug_1.default('skipping removeHeader', name);
                                }
                                debug_1.default('res.removeHeader - end');
                            };
                            debug_1.default('res.writeHead');
                            resWriteHead_1 = res.writeHead;
                            // @ts-ignore
                            res.writeHead = function (statusCode, reason, obj) {
                                debug_1.default('res.writeHead - start');
                                if (typeof reason === 'string') {
                                    // assume this was called like this:
                                    // writeHead(statusCode, reasonPhrase[, headers])
                                }
                                else {
                                    // this was called like this:
                                    // writeHead(statusCode[, headers])
                                    obj = reason;
                                }
                                debug_1.default('res.statusCode', res.statusCode);
                                if (statusCode === 200 || statusCode === 204) {
                                    var wsContextHeaders = wsContext_1.toHeaders();
                                    debug_1.default("Adding wsContext headers", wsContextHeaders);
                                    obj = Object.assign({}, obj, wsContextHeaders);
                                    // Koa will set status code 204 when the body has been set to
                                    // null. This is probably fine since the main stream
                                    // for WS-over-HTTP is supposed to have an empty
                                    // body anyway.  However, we will be adding WebSocket
                                    // events into the body, so change it to a 200.
                                    statusCode = 200;
                                    reason = 'OK';
                                }
                                debug_1.default('res.writeHead - end');
                                if (typeof reason === 'string') {
                                    // @ts-ignore
                                    resWriteHead_1.call(res, statusCode, reason, obj);
                                }
                                else {
                                    resWriteHead_1.call(res, statusCode, obj);
                                }
                            };
                            debug_1.default('res.end');
                            resEnd_1 = res.end;
                            // @ts-ignore
                            res.end = function (chunk, encoding, callback) {
                                debug_1.default('res.end - start');
                                debug_1.default('res.statusCode', res.statusCode);
                                if (res.statusCode === 200 || res.statusCode === 204) {
                                    debug_1.default('Getting outgoing events');
                                    var events = wsContext_1.getOutgoingEvents();
                                    debug_1.default('Encoding and writing events', events);
                                    res.write(grip_1.encodeWebSocketEvents(events));
                                }
                                debug_1.default('res.end - end');
                                // @ts-ignore
                                resEnd_1.call(res, chunk, encoding, callback);
                            };
                            debug_1.default('Monkey-patch res methods for WS-over-HTTP - end');
                        }
                        else {
                            debug_1.default('Monkey-patch res methods for GripInstruct - start');
                            debug_1.default('res.writeHead');
                            resWriteHead_2 = res.writeHead;
                            // @ts-ignore
                            res.writeHead = function (statusCode, reason, obj) {
                                debug_1.default('res.writeHead - start');
                                if (typeof reason === 'string') {
                                    // assume this was called like this:
                                    // writeHead(statusCode, reasonPhrase[, headers])
                                }
                                else {
                                    // this was called like this:
                                    // writeHead(statusCode[, headers])
                                    obj = reason;
                                }
                                debug_1.default('res.statusCode', res.statusCode);
                                if (gripInstruct_1 != null) {
                                    debug_1.default("GripInstruct present");
                                    if (statusCode === 304) {
                                        // Code 304 only allows certain headers.
                                        // Some web servers strictly enforce this.
                                        // In that case we won't be able to use
                                        // Grip- headers to talk to the proxy.
                                        // Switch to code 200 and use Grip-Status
                                        // to specify intended status.
                                        debug_1.default("Using gripInstruct setStatus header to handle 304");
                                        statusCode = 200;
                                        reason = 'OK';
                                        gripInstruct_1.setStatus(304);
                                    }
                                    // Apply prefix to channel names
                                    gripInstruct_1.channels = gripInstruct_1.channels.map(function (ch) { return new grip_1.Channel(_this.prefix + ch.name, ch.prevId); });
                                    var gripInstructHeaders = gripInstruct_1.toHeaders();
                                    debug_1.default("Adding GripInstruct headers", gripInstructHeaders);
                                    obj = Object.assign({}, obj, gripInstructHeaders);
                                }
                                else {
                                    debug_1.default("GripInstruct not present");
                                }
                                debug_1.default('res.writeHead - end');
                                if (typeof reason === 'string') {
                                    // @ts-ignore
                                    resWriteHead_2.call(res, statusCode, reason, obj);
                                }
                                else {
                                    resWriteHead_2.call(res, statusCode, obj);
                                }
                            };
                            debug_1.default('Monkey-patch res methods for GripInstruct - end');
                        }
                        return [3 /*break*/, 7];
                    case 6:
                        ex_2 = _a.sent();
                        throw ex_2 instanceof Error ? ex_2 : new Error(ex_2);
                    case 7:
                        debug_1.default('ServeGrip#run - end');
                        return [2 /*return*/, true];
                }
            });
        });
    };
    return ServeGrip;
}(callable_instance_1.default));
exports.default = ServeGrip;
//# sourceMappingURL=ServeGrip.js.map